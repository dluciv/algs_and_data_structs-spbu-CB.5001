<span id="slides-title" hidden>Линейные контейнеры</span>

# Указатели

- - - - - - - - - - - -

### Указатель

-   м.б. многокомпонентный (с сегментом, например), что затрудняет
    сравнение

-   м.б. в разной степени относительный

-   может иметь фактически неиспользуемые младшие биты (битовая
    упаковка)


- - - - - - - - - - - -

### Ссылочные и контейнерные типы

-   контейнерный тип

    -   при присваивании копируется значение

    -   выделяется обычно на стеке или в \<\<сегменте статических
        данных\>\>

    -   легко оптимизируется компилятором

    -   пример — `C char`

-   ссылочный тип

    -   при присваивании копируется ссылка

    -   выделяется обычно в куче

    -   тяжело оптимизируется кем угодно

    -   пример — `строка C`


= = = = = = = = = = = =

Массивы
=======

- - - - - - - - - - - -

Одномерные
----------

### Минимум

Необходимый минимум:

-   адрес 0 (или 1) элемента

-   размер одного элемента

<div class="fragment" />
Чуть больше:

-   1 или 2 границы массива

### Языки без структур данных

-   Fortran 77

-   Классический BASIC

<div class="fragment" />
Массив структур $\rightarrow$ несколько массивов.

- - - - - - - - - - - -

Многомерные, мягкие и массивы массивов
--------------------------------------

### Паспорт многомерного массива

Служебная структура данных, содержащая для каждого измерения:

-   адрес элемента с индексом 0

-   возможно только во время компиляции

    -   границы измерения

    -   размер элемента

### Хранение многомерного массива

-   Левый индекс старший (семейство C)

-   Правый индекс старший (Фортран)

- - - - - - - - - - - -

### Вектор Айлифа (массив ссылок на массивы)

Дж. Айлифф, 1961. [](http://en.wikipedia.org/wiki/Iliffe_vector).

Из современных ЯВУ используются в C (`int**` или `int*[]`, но не
`int[][N]`), Java, Perl, Python, Ruby.

В Java массив — всегда ссылочный тип, в Pascal — контейнерный. В C и
C$\sharp$ — по-разному, в Perl, Python, Ruby — массивов, как
таковых, нет, вместо них списки.

-   используются для реализации многомерных массивов

-   массив хранит ссылки на массивы следующего уровня

-   позволяют отказаться от умножения

-   позволяют делать массивы нижних уровней переменной длины

- - - - - - - - - - - -

### Многомерный массив и вектор Айлифа

![image](diagrams/array){width="9cm"}

    A[i,j]^ = A^ + s * ((i_u-i_l+1)*i + j);
    I[i]^ = I + sp * i; A[i,j]^  = I[i] + s * j;

= = = = = = = = = = = =

Динамические линейные контейнеры
================================

- - - - - - - - - - - -

Свойства
--------

### Массив

Является встроенной структурой данных большинства типичных
алгоритмических императивных языков. Будет рассмотрен, в связи с этим, в
соответствующем разделе.

-   Однороден по размеру и, обычно, природе элементов;

-   хорошо поддерживается аппаратурой и оптимизируется компиляторами;

-   не позволяет, в общем случае, изменять свой размер. Сначала он
    слишком пустой, потом слишком полный;

-   не имеет топологии – данные идут подряд, при реструктуризации
    необходимо их все перемещать.

- - - - - - - - - - - -

### Список

![image](diagrams/lists_uml){width="8cm"}

В зависимости от реализации может быть в различной степени избыточен по
памяти.

- - - - - - - - - - - -

### Курсор/итератор

Атомарный объект или структура для:

-   доступа к текущему элементу контейнера

-   сдвига вперёд и/или назад

-   иногда — доступа к элементу по индексу

<div class="fragment" />

Курсор массива — обычно просто указатель.


- - - - - - - - - - - -

Списки
------

### Топологии

-   Односвязный. Навигация только от головы к хвосту, неизбыточная
    структура;

-   шитый. Навигация от головы к хвосту, но с указателями на далеко
    стоящие элементы;

-   двусвязный. Требует изменяемых структур данных, не поддерживается
    некоторыми языками (Caml, Haskell). Навигация в обе стороны.

-   [\[cross:zipper\]]{#cross:zipper label="cross:zipper"} Zipper.
    Компромиссный вариант. Навигация в обе стороны, но односвязный. Как
    молния с двумя замками.

- - - - - - - - - - - -

Списки
------

### Реализация

При помощи:

-   Указателей. В структуре выделяется место под адрес следующего (и,
    для двусвязного, предыдущего) элементов.

-   Массива. Элементы лежат подряд. Для вставки и удаления – сдвиг.
    Совсем неизбыточная структура. Быстрая индексация.

-   Массива с курсорами. Курсоры – индексы массива, имитирующие
    указатели. Требуется самостоятельно реализовывать алгоритмы
    выделения и освобождения памяти. Для языков без структур данных ---
    отдельные массивы для данных списка и для топологии.

-   Ленивых генераторов (односвязный) – сопроцедуры, comprehension.

-   Обеспечения доступа к элементам через итераторы (могут учитывать
    оптимизации при перестройке списков).

- - - - - - - - - - - -

### Zipper

![image](diagrams/lists){width="10cm"}

### Оптимизация

При помощи:

-   Хранения по нескольких элементов в объекте (блочный список). Это
    уменьшает количество объектов и разгружает кучу, но при
    редактировании списка вызывает фрагментацию и может потребовать
    дефрагментации (с потерей актуальности указателей, которые при такой
    модели вообще не очень уместны, а уместны сложные итераторы).

-   Крайние элементы списка можно хранить в локальных переменных. Это
    ускорит доступ к началу (и, для двусвязного, концу) списка и
    позволит не выделять динамически память для коротких списков.

-   При использовании неизменяемых структур данных для получения списка,
    начинающегося с середины имеющегося, не надо копировать данные.

- - - - - - - - - - - -

### Блочный список

![image](diagrams/lists){width="10cm"}

### Продвинутая оптимизация: с пропусками I

Отсортированные списки продвинуто оптимизируется при помощи
иерархических пропусков. [](http://habrahabr.ru/blogs/algorithm/111913/)
[](http://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%
%D1%81_%D0%BF%D1%80%D0%BE%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D0%BC%D0%B8)

Строится иерархия шитых списков (сразу много ссылок на следующий):
каждый следующий список $P_i$ будет содержать каждый $k$-й элемент
предыдущего списка $P_{i-1}$.

-   Поиск происходит за $\log_k N$.

-   Вставка:

    1.  ищем, куда вставить, вставляем в нижний список;

    2.  с вероятностью $\frac{1}{k}$ повторяем для предыдущего списка, с
        вероятностью $1 - \frac{1}{k}$ заканчиваем работу;

    3.  если не дошли до верха, то повторяем п. 2.

-   Удаление: просто удаляем элемент отовсюду.

- - - - - - - - - - - -

### Продвинутая оптимизация: с пропусками II

![image](diagrams/skip_list){width="10cm"}

Прочие
------

- - - - - - - - - - - -

### Очередь

Реализуется при помощи:

-   Двусвязного списка;

-   односвязного списка с указателем на последний элемент (неизбыточна);

-   циклического массива. Одного или нескольких (в аппаратуре – DMA).

![image](diagrams/fastqueue){width="8cm"}

\vspace{-3cm}

- - - - - - - - - - - -

### Стек

Фактически, односвязный список, со всеми его частностями. И больше
ничего. Два стека — Zipper.

В языках программирования без поддержки рекурсии (даже первые версии Си)
применялся для имитации рекурсии вручную. На многих архитектурах \<\<с
историей\>\>, типа IBM3x0, до сих пор аппаратно не поддерживается.

### Дек

Структура данных, подразумевающая просмотр, добавление и удаление
элементов с обоих концов. Реализуется при помощи, как минимум,
двусвязного списка.

