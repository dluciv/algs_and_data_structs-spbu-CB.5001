<span id="slides-title" hidden>И снова хэш-функции</span>

## О чём пойдёт речь

* Качество и свойства не криптографических хэш-функций
* Семейства криптографических хэш-функций

= = = = = =

# Универсальные и совершенные хэш-функции

- - - - - -

## Вероятность коллизии

$h: A \rightarrow I$

$$\operatorname{P}(h(x) = h(y)) = \sum_1^{|I|} \frac{1}{|I|^2} = \frac{1}{|I|}$$

- - - - - -

## Если функция — основа таблицы

Если используется внутреннее расширение, то время поиска элемента в таблице c $m$ элементами — длина цепочки

$$\operatorname{E}(t(x)) = \operatorname{E}\left(\sum_{i=1}^M \operatorname{I}(h(x) = h(y_i))\right) = \sum\operatorname{E}(\ldots) \le \frac{m-1}{n} + 1 \stackrel{m\le |I|}{\le} 2$$

@pause@

**Универсальная хэш-функция** — такая, верроятность коллизий для $\forall x \in A$ может быть оценена, как показано выше

- - - - - -

## Rehashing

1. Хэш-функции брать с с запасом по $|I|=2^{?}$.
2. Делать ячеек в таблице $2^{j} \ll |I| ,$
3. При заполнении таблицы до какой-то степени увеличивать $j$ на 1 и перестраивать
   * долго
   * каждый следующий раз дольше
   * каждый следующий раз дальше

- - - - - -

## Методы перестройки

[Вот такие](https://dluciv.github.io/algs_and_data_structs-spbu-CB.5001/slides.html?md=08.hashtables#/3/7/0)

- - - - - -

## Постороение универсальных хэш-функций

Для $I = \{0,1,\ldots,n-1\}$

Известно, что $\forall n \exists$ простое $p \in \{n,\ldots,2n\}$

Тогда возьмём $0 < a < p$ и $0 \le b < p$ и определим (для $А\approx \mathbb{Z}$)

$$h(x) = (ax + b) \mod p \mod n$$

@pause@

Сравнительно несложно доказать, что [такая хэш-функция является универсальной](https://youtu.be/ekySO1jzv9M?t=239) для любых различных $a$ и $b$.

Получается, для организации хэш-таблиц такие функции действительно хорошо подходят.

- - - - - -

## Хэш-функции для строк

Точнее, битовых последовательностей.

Если нам нужно на вход число $\mathbb{Z}\cap[0,n=2^d)$, а есть $m$ битов, т.е. $\\{0, 1\\}^m$.

Если мы линейно преобразуем биты случайной матрицей $M \in \\{0,1\\}^{d\times m}$ над $\mathbb{Z}/2$, то получим случайную $h': \\{0,1\\}^m \rightarrow I$.

Также сравнительно легко [доказать, что $h'$ будет универсальной](https://youtu.be/iYwrK02_-6Y?t=317).

- - - - - -

## Совершенные хэш-функции

**Совершенная хэш-функция** для данного множества аргументов — такая, которая не имеет на нём коллизий.

- - - - - -

## Для мощных функций от не мощных аргументов

Если $|I| \ge |A|^2$, то случайная хэш-функция будет совершенной с веросятностью $\ge 1/2$. [Тоже легко доказать](https://youtu.be/bNH3bBlApHk?t=239) через [оценку Буля](https://en.wikipedia.org/wiki/Boole%27s_inequality).

@pause@

Вероятность коллизии у произвольной хэш-функции:

$$\operatorname{P}(\exists x, y \in A, x\neq y, h(x)=h(y)) \leq \sum_{x,y\in A}\operatorname{P}(h(x)=h(y)) \leq$$

$$\leq \frac{1}{|I|}\operatorname{C}^{|A|}_2 = \frac{|A|(|A|-1)}{2|I|} \overset{\mathrm{см. выше}}{\le} \frac{1}{2}$$

- - - - - -

Пример: [Генерация совершенных функций для небольших фиксированных множеств](https://web.archive.org/web/20201211134615/https://www.ibm.com/developerworks/ru/library/l-gperf/l-gperf-pdf.pdf)

- - - - - -

## Совершенные хэш-таблицы

$|I| \ge |A|^2$ одним куском уж больно расточительно. Поэтому представим себе 2-х уровневую хэш-таблицу.

* Первый уровень $g: A \rightarrow I = \{0,\ldots,n-1\}$ — универсальная хэш-функция
* Второй уровень $\forall i \in I$, $h_i$ — совершенная хэш-ф-ция, выдающая $\mathit{load}^2(i) = |x \in A: g(x) = i|$

@pause@

[Сравнительно несложно доказать](https://youtu.be/bNH3bBlApHk?t=500), что

$$\sum_{i=0}^{n-1} \mathit{load}^2(i) < 2n$$


= = = = = =

# Практичные, но не криптографические

- - - - - -

## Хэш-функции на практике

* Qt, [похоже](https://github.com/qt/qtbase/blob/e1440dd7bc1a5da9a536f88b9733d04ec8fa6e61/src/corelib/tools/qhash.cpp#L84)
* Chromium, тоже [похоже](https://source.chromium.org/chromium/chromium/src/+/master:base/hash/hash.cc;drc=c3cffa634ce1fd84baaab5ba507e240b8abbd977;l=43)
* libxml2, [не похоже](https://gitlab.gnome.org/GNOME/libxml2/-/blob/649d02eaa419fa72ae6b131718a4ac77063d7a5a/hash.c#L86)

- - - - - -

## Хэш-таблицы: двойное хэширование, как замена повторному

Если с $h_1(x)$ столкнулись с колизией, то берём $h_1(x) + h_2(x)$, а затем — $h_1(x) + 2h_2(x)$ и т.д. — такое сильно понижает вероятность коллизии, но не сильно повышает количество вычислений хэш-ф-ций

= = = = = =

# Криптографические хэш-функции

- - - - - -

## Блочные шифры

Основное достижение (по сравнению с шифроблокнотами) — шифрование сообщений длиннее, чем ключ.

Данные делятся на блоки. Типичный порядок раунда для блока:

* XOR, сложение или другая простая ф-ция для 
* *Не теряющие энтропию* (для внешнего наблюдателя) перестановки и линейные преобразования в ключе
* *Обратимые* перестановки и линейные преобразования в данных
* Опционально — использование части зашифрованных даных для модификации ключа или сосотояния енкодера/декодера перед последующими раунадми

@pause@

* Первый опубликованный — Lucifer, IBM, 1970. До этого вероятно лишь военные.
* И [да, русская Википедия!](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%88%D0%B8%D1%84%D1%80)

Криптостойкость может расти линейно с количеством раундов

- - - - - -

## Необратимые функции сжатия

Обычно, превращающие две порции данных в одну. Для необратимости часто используют алгоритмы блочных шифров.

- - - - - -

## Класс Меркла-Дамгора

Основаная идея:

* Разбить данные на блоки, выровнять последний по длине (и дописать исходную длину)
* Взять (постоянный) начальный ключ, инициализировать им состояние кодировщика
* «Скармливать» на каждой итерации функции сжатия очередной блок и выход (состояние) предыдущей итерации
* После окончания *возможно* сжать результат или выдать сосояние кодировщика в неизменном виде

@pause@

Опять [Википедия, правда уже английская](https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction)

- - - - - -

## Примеры: MD5 и SHA-2

И снова Википедия!

* [MD5](https://en.wikipedia.org/wiki/MD5)
* [SHA-2](https://en.wikipedia.org/wiki/SHA-2)

- - - - - -

## Во что бы то ни стало =)

Главное — при сжатии не терять энтропию, сохранять хаос.

*— И  потом... — Челнов облучил Сологдина мерцанием своего взгляда, — потом  не забывайте: ваша  шифровка  строится  по хаотическому принципу, это хорошо.  Но хаос,  однажды  выбранный, хаос застывший  —  есть уже система. Сильнее было  бы усовершенствовать решение  так,  чтобы хаос  ещё хаотически менялся.*

Солженицын А. И. В круге первом

@pause@

*— Я говорю вам: нужно носить в себе ещё хаос, чтобы быть в состоянии родить танцующую звезду*

Ницше Ф. Так говорил Заратустра

- - - - - -

## Атака удлиннением сообщения

Значение хэш-функции — фактически всё её внутреннее состояние. Значит, получив её значение и зная длину, можно её «оживить» на той точке, где она остановилась.

[Да, опять туда](https://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%B0%D0%BA%D0%B0_%D1%83%D0%B4%D0%BB%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F)

- - - - - -

## Класс [Keccak](https://crypto.stackexchange.com/a/9975), «Губка»

Могут принимать и выдавать произвольное количество данных

Фаза впитывания:

1. Выравнивание
2. XOR с небольшим кол-вом битов данных
3. Перестановка
4. GO TO 2

Фаза выжимания

1. Выдача небольшого кол-ва битов
2. Перестановка
3. Повтор

@pause@

Пример: SHA-3

- - - - - -

## Неподверженность Keccak удлиннению сообщения

На перестановках, по крайней мере, очевидно, что хаос не теряется. И результата выдаётся не то чтобы много, а ровно сколько попросят.

- - - - - -

## SWIFFT


* Хэш-функция задаётся $m$ многочленами $a_i$ степени $n$, к их коэффициентам применяется БПФ и неприводимым многочленом $\alpha$ и числом (лучше простым) $p$
* Данные блоков преобразуются в коэффициенты $m$ многочленов степени $n$, к ним тоже БПФ
* Многочлены функции и данных почленно перемножаются
* Обратное БПФ даёт $m$ многочленов степени $\le 2n$
* Их складывают $\mod p \mod \alpha^n + 1$
* На выходе — коэффициенты суммы в количестве $n\log_2 p$ бит

И гордая [ссылка на русскую Википедию](https://ru.wikipedia.org/wiki/SWIFFT#%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B)!

@pause@

Ничего не напоминает? С многочленами

= = = = = =

## Литература

* Кратко — несколько [лекций CS-клуба](https://compsciclub.ru/courses/advancedalgorithms/2020-autumn/classes/)
* Константин Макарычев. [Advanced Algorithms](https://www.advancedalgorithms.com/ru/).
* [Использование gperf для эффективной обработки параметров командной строки в C/C++](https://web.archive.org/web/20201211134615/https://www.ibm.com/developerworks/ru/library/l-gperf/l-gperf-pdf.pdf) / IBM Developer Works, 2007
* R.C. Merkle. [Secrecy, authentication, and public key systems](http://www.merkle.com/papers/Thesis1979.pdf). Stanford Ph.D. thesis 1979, pages 13-15.

= = = = = =

## Вопросы

* Что такое коллизия хэш-функции?
* Что такое универсальная хэш-функция?
* Что такое совершенная хэш-функция?
* Опишите прнцип построение двухуровневой хэш-таблицы
* Зачем применяется двойное хэширование?
* Что такое блочный шифр?
* Что такое криптографическая функция сжатия?
* Опишите принципы построения функций класса Меркла-Дамгора, приведите примеры
* Опишите атаку удлиннением сообщения
* Опишите принципы построения функций класса Keccak, приведите примеры
* Опишите принципы построения функций класса SWIFFT
