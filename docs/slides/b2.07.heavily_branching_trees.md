<span id="slides-title" hidden>Сильноветвящиеся деревья</span>
<span id="slides-author" hidden>Сартасов С.Ю., Луцив Д.В.</span>

B-дерево
========

- - - - - -

## Термины и определения

Придумали Р. Байер и Э. Мак-Крейт, 1972 (М. Кауфман – не опубликовал)

B-дерево порядка $2t$ (по БМК) или $2t+1$ (по Кнуту) удовлетворяет
условиям:

-   В листьях дерева хранится $t \ldots 2t$ числа.

-   В узлах дерева хранятся кроме этого ссылки на $t+1 \ldots 2t+1$
    поддерева.

- - - - - -

## Расхождения в определениях

-   Р. Байер и Э. Мак-Крейт в исходной статье листьями называли нижний
    уровень вершин с ключами, соответственно с другой аксиоматикой.
    Пустые листья предложил Д. Э. Кнут.

-   Некоторые определения оперируют количеством ключей, а не детей.

[Порядок 2 (БМК 1972) или 5 (К 1998)](https://en.wikipedia.org/wiki/B-tree#Overview)

<div style="text-align: center;">

![B](images/07.B-tree.svg) <!--.element: style="width: 60%;" -->

</div>

- - - - - -

## Свойства B-дерева

-   Сильно ветвистое ($t$ велико)

-   Идеально сбалансировано по высоте

-   Внутренние узлы заполнены минимум наполовину

Используется при организации индексов в СУБД и файловых систем (NTFS, BTRFS).
Нижние уровни часто выносятся во внешнюю память.

А почему?..

<div class="fragment" />

... А потому, что сильно ветвистое. Например, первые 4 уровня в ОЗУ и следующие 4 на диске позволят искать данные в среднем вдвое быстрее, чем целиком на диске.

- - - - - -

# Вставка

1. Добавить узел в соответствующее место в соответствующем листе.

2. В случае переполнения — разделить узел на два, число посередине
   вставить в родительский узел. Повторять до корня.

- - - - - -

<div style="text-align: center;">

![BI](images/07.trees.b1.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

<div style="text-align: center;">

![BI](images/07.trees.b2.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

<div style="text-align: center;">

![BI](images/07.trees.b3.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

<div style="text-align: center;">

![BI](images/07.trees.b4.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

## Удаление

Пример с переливанием

<div class="fragment" />

Пусть в дереве порядка 2 (5) в одном из внутренних узлов 2 значения, а в его братьях — по 4. Одно из 2-х значений требуется удалить.
Слить уел с братьями нельзя, т.к. в братьях уже максимальное количество данных.

<div class="fragment" />

Выход — выбрать одного из братьев в качестве донора, переместить значение из родителя в пустой узел, а из одного из наполненных братьев — в родителя.

- - - - - -

## Оценки сложности

-   Верхняя оценка высоты - $h \le \lfloor \log_t ((N+1)/2) +1\rfloor$
-   Время поиска $\mathcal{O}(\log_2 t \log_t N)$
-   Время вставки $\mathcal{O}(\log_2 t \log_t N)$

- - - - - -

## Балансировка

* B-дерево идеально сбадансировано лишь по высоте. Если брать количество данных в разных ветвях, оно может оказаться заметно «кривым»
* В зависимости от задаи, можно переливать и при вставке, дерево будет реже разделяться, зато разделения будут затрагивать больше узлов

= = = = = =

# R-деревья

- - - - - -

## Термины и определения

R-дерево — обобщение B-дерева на случай многомерных объектов. Для
двумерного случая — фигуры на плоскости, отрезки, точки

Максимальное количество элементов в узле - $M \ge 2$

Минимальное количество элементов в узле - $m \le M/2$

- - - - - -

## Организация

-   Запись в узле дерева — минимальный прямоугольник со сторонами,
    параллельными осям координат, в который можно вписать хранимый(е)
    ниже объект(ы).

-   В корне — минимум 2 объекта (если он не является листом, тогда,
    возможно, меньше)

-   В листе — от $m$ до $M$ записей (если он не является корнем)

-   В промежуточном узле — от $m$ до $M$ записей

- - - - - -

## В идеале

<div style="text-align: center;">

![R](images/07.trees.r1.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

## И в жизни

<div style="text-align: center;">

![R](images/07.R-tree.svg) <!--.element: style="height: 80%;" -->

</div>

- - - - - -

## Свойства

-   Сильно ветвистое

-   Сбалансированное по высоте

-   Вхождение в прямоугольник не гарантирует положительного результата
    поиска

-   Возможное пересечение прямоугольников внутри одного элемента —
    неоднозначность поиска

Поиск объектов, входящих в данную область. Очень упрощённо —
Определение объекта экранной формы, на который щёлкнули мышкой

- - - - - -

## Алгоритм вставки

Похож на B-дерево

<div class="fragment" />

Упрощённый вариант разделения

-   Взять наибольшее измерение параллелотопа
-   Найти «центр масс» по этому измерению
-   Разделить по центру масс

- - - - - -

<div style="text-align: center;">

![R](images/07.trees.r2.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

<div style="text-align: center;">

![R](images/07.trees.r3.svg) <!--.element: style="width: 80%;" -->

</div>

- - - - - -

<div style="text-align: center;">

![R](images/07.trees.r4.svg) <!--.element: style="width: 80%;" -->

</div>

= = = = = =

# Интервальное дерево

<div class="fragment" />

**Внимание!** Ниже будет неуместное число деталей и примеров работы с литературой.
Они приведены в качестве иллюстрации реальной проработки материала во время научной
работы. Во время аттестации столько подробностей не нужно, следует рассказать
приблизительно так же, как и про остальные деревья.

- - - - - -

## Задача

* Дано множество интервалов
* Зная границы интервала, научиться определять, с какими интервалами данного множества он пересекается. *По возможности быстро.*

- - - - - - - - - - - - -

## Требуется вспомогательная структура данных

Свойства:

1. Инициализируется множеством интервалов
2. Позволяет удалять и добавлять интервалы
3. Позволяет искать интервалы, пересекающиеся с данным
   за $\mathcal{O}(N log_2 N + M)$, где $N$ — число интервалов в дереве, $M$ — количество выданных интервалов

- - - - - - - - - - - - -

## Почему хорошо подходит **именно дерево**?

Хватило бы двух массивов:

* Отсортированные массивы начал и концов интервалов
* Бинарным поиском ищем, начиная с какого интервала конец искомого интервала совпадает или правее конца хранимых
* Аналогично — до какого интервала начало искомого левее или совпадает с концами хранимых
* Пересекаем эти два множества
* PROFIT

Но **массивы тяжело редактировать!**

Редактировать хорошо список, но по списку не поищешь бинарным поиском.

- - - - - -

Дерево — компромисс для многих задач, и для интервалов тоже:
* По деревьям можно быстро искать
* Их можно быстро редактировать

- - - - - -

## Построение по набору отрезков:

1.  Дано множество интервалов
2.  Нахдится «центр масс» множества
3.  Интервалы строго слева от центра идут в левое поддерево
4.  Интервалы строго справа — в правое
5.  Список оставшихся (включающих центр) остаётся в узле
6.  Левое и правое поддеревья рекурсивно строятся для соответствующих
    подмножеств, пока они не пусты

[More](http://en.wikipedia.org/wiki/Interval_tree)

- - - - - -

## Поиск в интервальном дереве

При поиске точки, она ищется в вершине и в одном из поддеревьев

При поиске интервала ищется, с какими интервалами он пересекаются,
производится рекурсивный спуск с учётом его границ

- - - - - -

# Разные описания из литературы

- - - - - - - - - - - - -
## Preparata и Shamos: источник

Franco P. Preparata, Michael Ian Shamos. Computational Geometry: an Introduction. Springer Monographs in Computer Science, 1985

Sec. 8.8.1, pp. 359–363

Цитируют:
* H. Edelsbrunner. Dynamic rectangle intersection searching. Institute for Information Processing Technical Report 47, Technical University of Graz, Graz, Austria, February 1980
  **не добыл**
  [Google Books](https://books.google.ru/books/about/Dynamic_Data_Structures_for_Orthogonal_I.html?id=iSGHPgAACAAJ&redir_esc=y)
* E. M. McCreight, Priority search trees, Tech. Rep. Xerox PARC CSL-81-5, 1981
  **не добыл**

Зато на [сайте Duke University Department of Computer Science](https://www.cs.duke.edu/)
[добыл](https://users.cs.duke.edu/~edels/Papers/) на [страничке Эдельсбруннера](http://pub.ist.ac.at/~edels/)

другой Technical Report:
[Dynamic Data Structures for Orthogonal Intersection Queries](https://users.cs.duke.edu/~edels/Papers/1980-R-01-OrthogonalIntersectionQueries.pdf). Sec. 2.2., pp. 23–32.

Добыл, схоронил на Archive.org, и, как выясняется, не зря. Что попало в Интернет, остаётся в нём навсегда =).

Ещё можно связаться с Эдельсбруннером =)...

- - - - - - - - - - - - -

## Preparata и Shamos: хранение

Для каждой вершины $w$ храним:
* медиану $\delta(w)$
    * В поддереве $w$ находится $M$ отрезков, их границы — $y_1, \ldots y&#95;{M+1}$, берётся $\delta(w) = (y_M + y&#95;{M+1})/2$
* Левые и правые концы отрезков, содержащих $\delta(w)$, обозначаются, как $\mathcal{L}(w)$ и $\mathcal{R}(w)$.
  Так что сами отрезки обозначим (мы) $\mathcal{LR}(w)$: $\forall r \in \mathcal{LR}(w) ~ \delta(w) \in r$
* ссылки на левое и правое поддеревья с отрезками левее $\delta(w)$ (множество $I_L(w)$) и правее $\delta(w)$ (множество $I_R(w)$)

- - - - - - - - - - - - -

## Preparata и Shamos: поиск

Ищем, кто пересекается с отрезком $[b, e]$ в поддереве с вершины:

1. Идём от корня до *первой* вершины $w^\*$, у которой будет $\delta(w^\*) \in [b, e]$.
2. Пока не дошли до $w^\*$, для каждой вершины $w$:
    * Выдаём все отрезки $r \in \mathcal{LR}(w)$, такие что $[b, e] \cap r \ne \emptyset$.
    * Идём в левое поддерево, если $е < \delta(w)$ и в правое, если $\delta(w) < b$.
3. Когда дошли до $w^\*$:
    * Выдаём все отрезки $r \in \mathcal{LR}(w)$
    * Рекуррентно ищем, с кем $[b, \delta(w^\*)]$ пересекается в левом поддереве
    * Рекуррентно ищем, с кем $[\delta(w^\*), e]$ пересекается в правом поддереве

Для поиска во всём дереве ищем, начиная с корня.

- - - - - - - - - - - - -

## Preparata и Shamos: примечания

* У Preparata дополнительно описаны служебные структуры данных для эффективной балансировки
* В Dynamic Data Structures for Orthogonal Intersection Queries Эдельсбруннера также много деталей по организации данных для балансировки.

- - - - - - - - - - - - -

## de Berg

Mark de Berg, Otfried Cheong, Marc van Kreveld, Mark Overmars. Computational Geometry: Algorithms and Applications. 3rd ed. Springer-Verlag, 2008

Sec. 10.1., pp. 220—226.

Похоже на Preparata и Shamos, ссылаются на те же источники, но:

* другие обозначения при описании структур данных
* описывает только поиск точек, но *принципиально* алгоритм такой же, как у Preparata и Shamos

- - - - - - - - - - - - -

## Cormen

Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest. Introduction to Algorithms. 3rd ed. MIT Press, 2009. Sec. 14.3, pp. 348–355.

На базе красно-чёрного дерева с сортировкой по левому концу

* Дополняет (augment) красно-чёрное дерево верхними границами. При поиске **выдаёт только один интервал**, поэтому нам не интересно.
* Ссылается (на уровне «отдать должное») на Preparata, Michael Ian Shamos и на тех, на кого они ссылаются, но описывает по-другому

Также описано [тут](http://www.geeksforgeeks.org/interval-tree/).

= = = = = =

# Троичное дерево поиска строк

- - - - - -

## Описание

-   Каждый узел хранит один символ и ссылки на трёх детей — младшего,
    старшего и среднего:

    -   у младшего ребёнка символ строго перед символом вершины

    -   у старшего — строго после

    -   у среднего — продолжение строки

-   Каждый узел хранит либо признак конца строки, либо ссылку, возможно
    пустую, на значение, поставленное в соответствие ключу.

[More](https://en.wikipedia.org/wiki/Ternary_search_tree)


```
          c
        / | \
       a  u  h
       |  |  | \
       t  t  e  u
     /  / |   / |
    s  p  e  i  s
```

В плане хранения строк, левый и правый дети вершины на том же расстоянии от начала, что и символ в вершине

- - - - - -

## Поиск и вставка

Ищем строку:

-   Если символ в вершине совпал с очередным символом строки, продолжаем
    в среднем поддереве со следущего символа строки

-   Если меньше или больше, то по строке не двигаемся, а идём в
    поддеревья

<div class="fragment" />

Вставляем строку:

-   Пока у вершин есть дети, ищем очередные символы строки

-   Когда дошли до листа, начинаем наращивать средними детьми

= = = = = =

Дополнительно
=============

- - - - - -

## Префиксное дерево

Для хранения строк и связанных с ними значений.

В каждой вершине — тем или иным способом реализованный словарь,
позволяющий по следующему символу строки получить поддерево для
продолжения поиска.

Может ветвиться как очень сильно, так и не очень.

[More](http://en.wikipedia.org/wiki/Trie)

= = = = = =

## Представление графов

- - - - - -

Зависит от вида графа

-   Наивное
-   Двумерный массив (матрица)
    - В т.ч. разреженный
-   Одномерный массив

= = = = = =

## Вопросы

* Что такое B-дерево заданного порядка? Сформулируйте два определения
* Что такое операция переливания? Когда она возможна, когда необходима?
* Что такое R-дерево? Зачем применяются R-деревья?
* Приведите примеры использования троичных деревьев
* Опишите, что такое интервальное дерево?
* Какими методами можно представлять графы?

## Упражнения

* Воспользовавшись библиотекой для работы с графами для любого языка программирования, проверьте несколько алгоритмов, описанных в курсе дискретной математики
* Найти эффективный способ хранить треугольный двумерный массив, как одномерный (например, для представления ненаправленного графа)
