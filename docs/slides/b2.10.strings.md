<span id="slides-title" hidden>Строки</span>

# (Не)изменяемость

- - - - - -

Изменяемые
----------


### Обычно представляются массивами

- LASCII
  - C++, Ruby (внезапно)
  - встроенные в Turbo Pascal (макс. размен 255 фиксирован)
  - короткие в Delphi
  - иногда короткие локально, а длинные в куче
- ASCIIZ
  - C

<div class="fragment" />

Да, Ruby!

```
s1 = 'ABC'
s2 = s1
s1.sub! 'B', '_'
puts s2
```

Выдаст...

@pause@

```
A_C
```

Т.е. в Ruby изменяемая ссылочная строка. Смело!

- - - - - -

Неизменяемые (1)
------------

### Где и как

- Используются многими современными объектно - ориентированными
  системами, такими как .NET, Java, Python
- Представляют собой объекты, инкапсулирующие массив символов, но не
  дающие его изменять.

### Преимущества и недостатки

- Очень быстро копируются, т.к. копируются только ссылки, одинаковые
  строки могут храниться в одной и той же памяти.

- При любом изменении строки приходится создавать новый объект с новой
  строкой.

- Для конкатенации длинных строк принято использовать специальные
  объекты класса `StringBuffer` (Java), `StringBuilder` (.NET), `StringIO` (Python),
  реализующие изменяемые строки.

- - - - - -

Неизменяемые (2)
------------

### Экономия

- Разные объекты строкового тип могут ссылаться на фрагменты массивов
  (указывать в середину и хранить небольшое значение длины). Это
  требует аккуратного управления выделением памяти и возможности
  программирования на уровне C.

- .NET иногда делает подобные оптимизации.

= = = = = =

# Представление

- - - - - -

Списки
------

- - - - - -

### Haskell

-  Ленивость потенциально позволяет работать с бесконечными строками,
   например, с потоками текста.

-  Преимущества неизменяемых строк, в т.ч. хвост строки без
   копирования.

-  Скорость доступа к отдельным символам сильно зависит от того, как
   система оптимизирует работу со списками.

-  Конкатенация совсем не быстрая.

- - - - - -

Деревья
-------

- - - - - -

### Rope

Одна из самых известных реализаций — Rope — предложена Hans Boehm, HP
(автор одного из самых популярных консервативных сборщиков мусора для C)
в 1980 годах.

Использовалась при написании текстового редактора.

- - - - - -

### Подход

- Строка представляется при помощи бинарного дерева.

- В каждой вершине ссылки на потомков или на память с символами (или
  на другую реализацию строк). Во внутренних вершинах вместе со
  ссылками хранят длины строк, представленных левым и правым детьми
  (чтобы не пересчитывать).

- Структура неизменяемая, фрагменты дерева можно повторно использовать
  (получается направленный ациклический граф).

- - - - - -

### Операции

-   Конкатенация за константу, создается новая вершина, указывающая на
    строку и добавку.

-   Балансировка происходит путем вращения. Цель — не наименьшая
    высота, а примерно одинаковая длина строк в поддеревьях.

### Конкатенация

-   При конкатенации длинной строки и короткой добавки, однако, дерево
    получается неоптимальным.

-   Каждый раз перестраивать такое дерево невыгодно.

-   Но можно, если пользуемся счетчиком ссылок (имеем право, т.к. циклов
    нет) и уверены, что ссылка единственная, не создать новое дерево, а
    перестроить, используя старые вершины. Если система программирования
    позволяет, конечно. Haskell, например, не позволит.

= = = = = =

### Вопросы

* Каковы преимущества ссылочного хранения строк?
* Каковы преимущества контейнерного хранения строк?
* Какими способами можно ускорять конкатенацию?
* Что такое Rope?

### Упражнения

* Измерьте производительность конкатенации при использовании реализации строк и буферов в различных языках программирования. Объясните полученные результаты.
