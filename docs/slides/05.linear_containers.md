<span id="slides-title" hidden>Линейные контейнеры</span>

# Указатели

- - - - - - - - - - - -

## Указатель

-   м.б. многокомпонентный (с сегментом, например), что затрудняет
    сравнение

-   м.б. в разной степени относительный

-   может иметь фактически неиспользуемые младшие биты (битовая
    упаковка)


- - - - - - - - - - - -

## Ссылочные и контейнерные типы

-   контейнерный тип

    -   при присваивании копируется значение

    -   выделяется обычно на стеке или в «сегменте статических
        данных»

    -   легко оптимизируется компилятором

    -   пример — `C char`

-   ссылочный тип

    -   при присваивании копируется ссылка

    -   выделяется обычно в куче

    -   тяжело оптимизируется кем угодно

    -   пример — `строка C`


= = = = = = = = = = = =

Массивы
=======

- - - - - - - - - - - -

Одномерные
----------

### Минимум

Необходимый минимум:

-   адрес 0 (или 1) элемента

-   размер одного элемента

<div class="fragment" />
Чуть больше:

-   1 или 2 границы массива

### Языки без структур данных

-   Fortran 77

-   Классический BASIC

<div class="fragment" />
Массив структур $\rightarrow$ несколько массивов.

- - - - - - - - - - - -

Многомерные, мягкие и массивы массивов
--------------------------------------

### Паспорт многомерного массива

Служебная структура данных, содержащая для каждого измерения:

-   адрес элемента с индексом 0

-   возможно только во время компиляции

    -   границы измерения

    -   размер элемента

### Хранение многомерного массива

-   Левый индекс старший (семейство C)

-   Правый индекс старший (Фортран)


- - - - - - - - - - - -

## Вектор Айлифа (массив ссылок на массивы)

[Дж. Айлифф, 1961](http://en.wikipedia.org/wiki/Iliffe_vector).

Из современных ЯВУ используются в C (`int**` или `int*[]`, но не
`int[][N]`), Java, Perl, Python, Ruby.

В Java массив — всегда ссылочный тип, в Pascal — контейнерный. В C и
C\# — по-разному, в Perl, Python, Ruby — *динамические* массивы,
имитирующие списки.

-   используются для реализации многомерных массивов

-   массив хранит ссылки на массивы следующего уровня

-   позволяют отказаться от умножения

-   позволяют делать массивы нижних уровней переменной длины

- - - - - - - - - - - -

## Многомерный массив и вектор Айлифа

<div style="text-align: center;">

![Ailiff vector](images/05.ailiff.svg) <!--.element: style="width: 70%;" -->

</div>

    A[i,j]^ = A^ + s * ((i_u-i_l+1)*i + j);
    I[i]^ = I + sp * i; A[i,j]^  = I[i] + s * j;

= = = = = = = = = = = =

Динамические линейные контейнеры
================================

- - - - - - - - - - - -

Свойства
--------

- - - - - - - - - - - -

### Массив

Является встроенной структурой данных большинства типичных
алгоритмических императивных языков. Будет рассмотрен, в связи с этим, в
соответствующем разделе.

-   Однороден по размеру и, обычно, природе элементов;

-   хорошо поддерживается аппаратурой и оптимизируется компиляторами;

-   не позволяет, в общем случае, изменять свой размер. Сначала он
    слишком пустой, потом слишком полный;

-   не имеет топологии – данные идут подряд, при реструктуризации
    необходимо их все перемещать.

- - - - - - - - - - - -

## Список

Односвязный

<div style="text-align: center;">

![Linked Lists](images/05.singly-linked-list.svg) <!--.element: style="width: 60%;" -->

</div>

Двусвязный

<div style="text-align: center;">

![Linked Lists](images/05.doubly-linked-list.svg) <!--.element: style="width: 80%;" -->

</div>


В зависимости от реализации может быть в различной степени избыточен по
памяти.


(иллюстрации из Википедии)

- - - - - - - - - - - -

## Курсор/итератор

Атомарный объект или структура для:

-   доступа к текущему элементу контейнера

-   сдвига вперёд и/или назад

-   иногда — доступа к элементу по индексу

<div class="fragment" />

Курсор массива — обычно просто указатель.


- - - - - - - - - - - -

Списки
------

### Топологии

-   Односвязный. Навигация только от головы к хвосту, неизбыточная
    структура;

-   Шитый. Навигация от головы к хвосту, но с указателями на далеко
    стоящие элементы;

-   Двусвязный. Требует изменяемых структур данных, не поддерживается
    некоторыми языками (Caml, Haskell). Навигация в обе стороны

-   Zipper.
    Компромиссный вариант. Навигация в обе стороны, но односвязный. Как
    молния с двумя замками

- - - - - - - - - - - -

Списки
------

### Реализация

При помощи:

-   Указателей. В структуре выделяется место под адрес следующего (и,
    для двусвязного, предыдущего) элементов

-   Массива. Элементы лежат подряд. Для вставки и удаления — сдвиг.
    Совсем неизбыточная структура. Быстрая индексация

-   Массива с курсорами. Курсоры — индексы массива, имитирующие
    указатели. Требуется самостоятельно реализовывать алгоритмы
    выделения и освобождения памяти. Для языков без структур данных —
    отдельные массивы для данных списка и для топологии

-   Ленивых генераторов (односвязный) – сопроцедуры, comprehension

-   Обеспечения доступа к элементам через итераторы (могут учитывать
    оптимизации при перестройке списков)


- - - - - - - - - - - -

## Списки, реализованные при помощи массивов

На момент составления слайдов:

* [Python 3](https://github.com/python/cpython/blob/1aeeaeb79efa4de41f97b58547e23c2965ecabc5/Objects/listobject.c#L311); [ещё](https://stackoverflow.com/a/1090117)
* [Ruby](https://github.com/ruby/ruby/blob/073cc5e815fcf5178fe4e515fcde74dc3597adeb/array.c#L158) — ура, `memcpy`!; [ещё](https://www.reddit.com/r/ruby/comments/8p8gax/are_ruby_arrays_really_arrays/)
* [CLang `std::vector`](https://github.com/llvm-mirror/libcxx/blob/158cd4dca0225901dcd645c5581dff0f27264536/include/vector#L1616); [ещё](https://web.archive.org/web/20150806162750/http://www.gahcep.com/cpp-internals-stl-vector-part-1/)

<div class="fragment" />

<div style="text-align: center;">

![Chunked list](images/toy-story-meme-template.jpg) <!--.element: style="width: 50%;" -->

</div>


Т.е. динамические массивы повсюду.

<div class="fragment" />

[Насколько отрастает такой массив](https://en.wikipedia.org/wiki/Dynamic_array#Growth_factor)

- - - - - - - - - - - -

## «Настоящие» «Списки»

[Есть, наряду с массивами](https://medium.com/omarelgabrys-blog/data-structures-language-support-5f70f8312e84)

CLang `std::list` — [двусвязный](https://github.com/llvm-mirror/libcxx/blob/158cd4dca0225901dcd645c5581dff0f27264536/include/list#L379):

`__ptr_ = __ptr_->__next_;`, а ниже `__ptr_ = __ptr_->__prev_;`

Тоже не решает всех проблем, т.к. приходится часто выделять/освобождать память

<div class="fragment" />

### Упражнение

Для нескольких языков с разными реализациями измерить скорость индексации списка и вставки/удаления данных

- - - - - - - - - - - -

## Zipper

<div style="text-align: center;">

![Zipper](images/05.zipper.svg) <!--.element: style="width: 70%;" -->

</div>

### Упражнение

Реализовать на любом языке программирования с неизменяемыми структурами данных

- - - - - - - - - - - -

## Оптимизация

При помощи:

-   Хранения по нескольких элементов в объекте (блочный список). Это
    уменьшает количество объектов и разгружает кучу, но при
    редактировании списка вызывает фрагментацию и может потребовать
    дефрагментации (с потерей актуальности указателей, которые при такой
    модели вообще не очень уместны, а уместны сложные итераторы).

-   Крайние элементы списка можно хранить в локальных переменных. Это
    ускорит доступ к началу (и, для двусвязного, концу) списка и
    позволит не выделять динамически память для коротких списков.

-   При использовании неизменяемых структур данных для получения списка,
    начинающегося с середины имеющегося, не надо копировать данные.

- - - - - - - - - - - -

### Блочный список

<div style="text-align: center;">

![Chunked list](images/05.chunked_list.svg) <!--.element: style="width: 80%;" -->

</div>

Какой размер блока оптимален? Тот, который позволит быстро перемещать данные внутри блока.
Предположительно, максимальный размер, не превосходящий кэш-линию.

<div class="fragment" />

### Упражнение

Реализовать на любом языке программирования



- - - - - - - - - - - -

### Продвинутая оптимизация: с пропусками I

Отсортированные списки продвинуто оптимизируется при помощи
иерархических пропусков. [](http://habrahabr.ru/blogs/algorithm/111913/)
[](http://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%
%D1%81_%D0%BF%D1%80%D0%BE%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D0%BC%D0%B8)

Строится иерархия шитых списков (сразу много ссылок на следующий):
каждый следующий список $P\_i$ будет содержать каждый $k$-й элемент
предыдущего списка $P\_{i-1}$.

-   Поиск происходит за $\log_k N$

-   Вставка:

    1.  ищем, куда вставить, вставляем в нижний список;

    2.  с вероятностью $\frac{1}{k}$ повторяем для предыдущего списка, с
        вероятностью $1 - \frac{1}{k}$ заканчиваем работу;

    3.  если не дошли до верха, то повторяем п. 2.

-   Удаление: удаляем элемент отовсюду

- - - - - - - - - - - -

### Продвинутая оптимизация: с пропусками II

<div style="text-align: center;">

![Skip List](images/05.skip_list.svg) <!--.element: style="width: 80%;" -->

</div>

(иллюстрация из Википедии)

= = = = = = = = = = = =

# Прочие линейные контейнеры

- - - - - - - - - - - -

## Очередь

Реализуется при помощи:

-   Двусвязного списка;

-   односвязного списка с указателем на последний элемент (неизбыточна);

-   циклического массива. Одного или нескольких (в аппаратуре – DMA).

- - - - - - - - - - - -

## Стек

Фактически, односвязный список, со всеми его частностями. И больше
ничего. Два стека — Zipper.

В языках программирования без поддержки рекурсии (даже первые версии Си)
применялся для имитации рекурсии вручную. На многих архитектурах «с
историей», типа IBM3x0, до сих пор аппаратно не поддерживается.

## Дек

Структура данных, подразумевающая просмотр, добавление и удаление
элементов с обоих концов. Реализуется при помощи, как минимум,
двусвязного списка.

