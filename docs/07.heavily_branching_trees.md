<span id="slides-title" hidden>Сильноветвящиеся деревья</span>
<span id="slides-author" hidden>Сартасов С.Ю., Луцив Д.В.</span>

B-дерево
========

- - - - - -

## Термины и определения

Придумали Р. Байер и Э. Мак-Крейт, 1972 (М. Кауфман – не опубликовал)

B-дерево порядка $2t$ (по БМК) или $2t+1$ (по Кнуту) удовлетворяет
условиям:

-   В листьях дерева хранится $t \ldots 2t$ числа.

-   В узлах дерева хранятся кроме этого ссылки на $t+1 \ldots 2t+1$
    поддерева.

- - - - - -

## Расхождения в определениях

-   Р. Байер и Э. Мак-Крейт в исходной статье листьями называли нижний
    уровень вершин с ключами, соответственно с другой аксиоматикой.
    Пустые листья предложил Д. Э. Кнут.

-   Некоторые определения оперируют количеством ключей, а не детей.

[Порядок 2 (БМК 1972) или 5 (К 1998)](https://en.wikipedia.org/wiki/B-tree#Overview)

<div style="text-align: center;">
![B](images/07.B-tree.svg) <!--.element: style="width: 60%;" -->
</div>

- - - - - -

## Свойства B-дерева

-   Сильно ветвистое ($t$ велико)

-   Идеально сбалансировано по высоте

-   Внутренние узлы заполнены минимум наполовину

Используется при организации индексов в СУБД и файловых систем (NTFS, BTRFS).
Нижние уровни часто выносятся во внешнюю память.

А почему?..

<div class="fragment" />

... А потому, что сильно ветвистое.

- - - - - -

# Вставка

1. Добавить узел в соответствующее место в соответствующем листе.

2. В случае переполнения — разделить узел на два, число посередине
   вставить в родительский узел. Повторять до корня.

- - - - - -

<div style="text-align: center;">
![BI](images/07.trees.b1.svg) <!--.element: style="width: 80%;" -->
</div>

- - - - - -

<div style="text-align: center;">
![BI](images/07.trees.b2.svg) <!--.element: style="width: 80%;" -->
</div>

- - - - - -

<div style="text-align: center;">
![BI](images/07.trees.b3.svg) <!--.element: style="width: 80%;" -->
</div>

- - - - - -

<div style="text-align: center;">
![BI](images/07.trees.b4.svg) <!--.element: style="width: 80%;" -->
</div>

- - - - - -

## Удаление

Пример с переливанием

<div class="fragment" />

Пусть в дереве порядка 2 (5) в одном из внутренних узлов 2 значения, а в его братьях — по 4. Одно из 2-х значений требуется удалить.
Слить уел с братьями нельзя, т.к. в братьях уже максимальное количество данных.

<div class="fragment" />

Выход — выбрать одного из братьев в качестве донора, переместить значение из родителя в пустой узел, а из одного из наполненных братьев — в родителя.

- - - - - -

## Оценки сложности

-   Верхняя оценка высоты - $h \le \lfloor \log_t ((N+1)/2) +1\rfloor$
-   Время поиска $\mathcal{O}(\log_2 t \log_t N)$
-   Время вставки $\mathcal{O}(\log_2 t \log_t N)$

- - - - - -

## Балансировка

* B-дерево идеально сбадансировано лишь по высоте. Если брать количество данных в разных ветвях, оно может оказаться заметно «кривым»
* В зависимости от задаи, можно переливать и при вставке, дерево будет реже разделяться, зато разделения будут затрагивать больше узлов

= = = = = =

# R-деревья

- - - - - -

## Термины и определения

R-дерево — обобщение B-дерева на случай многомерных объектов. Для
двумерного случая — фигуры на плоскости, отрезки, точки

Максимальное количество элементов в узле - $M \ge 2$

Минимальное количество элементов в узле - $m \le M/2$

- - - - - -

## Организация

-   Запись в узле дерева — минимальный прямоугольник со сторонами,
    параллельными осям координат, в который можно вписать хранимый(е)
    ниже объект(ы).

-   В корне — минимум 2 объекта (если он не является листом, тогда,
    возможно, меньше)

-   В листе — от $m$ до $M$ записей (если он не является корнем)

-   В промежуточном узле — от $m$ до $M$ записей

- - - - - -

## В идеале

<div style="text-align: center;">
![R](images/07.trees.r1.svg) <!--.element: style="width: 80%;" -->
</div>

- - - - - -

## И в жизни

<div style="text-align: center;">
![R](images/07.R-tree.svg) <!--.element: style="height: 80%;" -->
</div>

- - - - - -

## Свойства

-   Сильно ветвистое

-   Сбалансированное по высоте

-   Вхождение в прямоугольник не гарантирует положительного результата
    поиска

-   Возможное пересечение прямоугольников внутри одного элемента —
    неоднозначность поиска

Поиск объектов, входящих в данную область. Очень упрощённо —
Определение объекта экранной формы, на который щёлкнули мышкой

- - - - - -

## Алгоритм вставки

Похож на B-дерево

<div class="fragment" />

Упрощённый вариант разделения

-   Взять наибольшее измерение параллелотопа
-   Найти «центр масс» по этому измерению
-   Разделить по центру масс

- - - - - -

<div style="text-align: center;">
![R](images/07.trees.r2.svg) <!--.element: style="width: 80%;" -->
</div>

- - - - - -

<div style="text-align: center;">
![R](images/07.trees.r3.svg) <!--.element: style="width: 80%;" -->
</div>

- - - - - -

<div style="text-align: center;">
![R](images/07.trees.r4.svg) <!--.element: style="width: 80%;" -->
</div>

= = = = = =

Троичные деревья
================

- - - - - -

Интервальное дерево
-------------------

- - - - - -

## Описание и построение

Похоже на R-дерево... или не похоже =)

А ещё оно не совсем троичное =)

Построение по набору отрезков:

1.  Дано множество интервалов
2.  Нахдится «центр масс» множества
3.  Интервалы строго слева от центра идут в левое поддерево
4.  Интервалы строго справа — в правое
5.  Список оставшихся (включающих центр) остаётся в узле
6.  Левое и правое поддеревья рекурсивно строятся для соответствующих
    подмножеств, пока они не пусты

[More](http://en.wikipedia.org/wiki/Interval_tree)

- - - - - -

## Поиск в интервальном дереве

При поиске точки, она ищется в вершине и в одном из поддеревьев

При поиске интервала ищется, с какими интервалами он пересекаются,
производится рекурсивный спуск с учётом его границ

- - - - - -

Троичное дерево поиска строк
----------------------------

- - - - - -

## Описание

-   Каждый узел хранит один символ и ссылки на трёх детей — младшего,
    старшего и среднего:

    -   у младшего ребёнка символ строго перед символом вершины

    -   у старшего — строго после

    -   у среднего — продолжение строки

-   Каждый узел хранит либо признак конца строки, либо ссылку, возможно
    пустую, на значение, поставленное в соответствие ключу.

[More](https://en.wikipedia.org/wiki/Ternary_search_tree)


```
          c
        / | \
       a  u  h
       |  |  | \
       t  t  e  u
     /  / |   / |
    s  p  e  i  s
```

В плане хранения строк, левый и правый дети вершины на том же расстоянии от начала, что и символ в вершине


- - - - - -

## Поиск и вставка

Ищем строку:

-   Если символ в вершине совпал с очередным символом строки, продолжаем
    в среднем поддереве со следущего символа строки

-   Если меньше или больше, то по строке не двигаемся, а идём в
    поддеревья

<div class="fragment" />

Вставляем строку:

-   Пока у вершин есть дети, ищем очередные символы строки

-   Когда дошли до листа, начинаем наращивать средними детьми

- - - - - -

Дополнительно
=============

### Префиксное дерево

Для хранения строк и связанных с ними значений.

В каждой вершине — тем или иным способом реализованный словарь,
позволяющий по следующему символу строки получить поддерево для
продолжения поиска.

Может ветвиться как очень сильно, так и не очень.

[More](http://en.wikipedia.org/wiki/Trie)

= = = = = =

# Представление графов

= = = = = =

Зависит от вида графа

-   Наивное
-   Двумерный массив (матрица)
    - В т.ч. разреженный
-   Одномерный массив

### Упражнение

Найти эффективный способ хранить треугольный двумерный массив, как одномерный
